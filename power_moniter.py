from sinabs.backend.dynapcnn import DynapcnnNetwork
import samna
import torch
from collections import Counter
from MyDataset import SpeckTacEventWindowDataset
from sinabs.backend.dynapcnn.dynapcnn_visualizer import DynapcnnVisualizer
from torch.utils.data import Subset
from tqdm import tqdm


# first define a callback function to modify the devkit configuration
# the callback function should only has 1 devkit config instance as its input argument
def config_modify_callback(devkit_cfg):

    # enable visualizing the output from dvs(pre-processing) layer
    devkit_cfg.dvs_layer.monitor_enable = True
    # disable visualizing the events generated by the embedded dvs on Speck
    devkit_cfg.dvs_layer.raw_monitor_enable = False
    # prevent the events generated by the embedded dvs been feed to the DynapCNN Core.
    devkit_cfg.dvs_layer.pass_sensor_events = False
    # point the dvs layer output destination to the core#0
    devkit_cfg.dvs_layer.destinations[0].enable = True
    devkit_cfg.dvs_layer.destinations[0].layer = 0

    # the callback must return the modified devkit config
    return devkit_cfg


final_model = torch.load("final_model.pth", map_location="cpu", weights_only=False)
dynapcnn = DynapcnnNetwork(snn=final_model, input_shape=(2, 128, 128), discretize=True, dvs_input=False)
devkit_name = "speck2fdevkit"
layers_to_monitor = [3]
# use the `to` method of DynapcnnNetwork to deploy the SNN to the devkit
dynapcnn.to(device=devkit_name, chip_layers_ordering=[0, 1, 2, 3], monitor_layers=layers_to_monitor, config_modifier=config_modify_callback)
print(f"The SNN is deployed on the core: {dynapcnn.chip_layers_ordering}")


visualizer = DynapcnnVisualizer(
    window_scale=(4, 8),
    dvs_shape=(128, 128),
    spike_collection_interval=500,
    add_power_monitor_plot=True,
)
visualizer.connect(dynapcnn)


snn_test_dataset = SpeckTacEventWindowDataset("data_all_surface_split_planE/test", window_us=(300_000, 800_000))
subset_indices = list(range(0, len(snn_test_dataset), 30))
snn_test_dataset = Subset(snn_test_dataset, subset_indices)

inference_p_bar = tqdm(snn_test_dataset)
test_samples = 0
correct_samples = 0
for events, label in inference_p_bar:
    # instead of creating Spike and send it to core#0 directly, we now create DvsEvent(for visualization) and send it to the DVS layer
    # since in the "config_modify_callback" we point the output destination layer of the DVS layer to layer/core #0
    # so the DynacnnCore can still receive the same input as before.
    samna_event_stream = []
    t0 = events[0]['t']
    for ev in events:
        dvs_ev = samna.speck2f.event.DvsEvent()
        dvs_ev.x = ev['x']
        dvs_ev.y = ev['y']
        dvs_ev.timestamp = ev['t'] - t0
        dvs_ev.p = ev['p']
        samna_event_stream.append(dvs_ev)

    # inference on chip
    # output_events is also a list of Spike, but .layer will have 0, 1, 2, 3 since we choose to monitor all layers' output
    output_events = dynapcnn(samna_event_stream)

    # get each layers output spikes
    layer0_spks = [each.feature for each in output_events if each.layer == 0]
    layer1_spks = [each.feature for each in output_events if each.layer == 1]
    layer2_spks = [each.feature for each in output_events if each.layer == 2]
    layer3_spks = [each.feature for each in output_events if each.layer == 3]
    # use the most frequent output neruon index as the final prediction
    if len(layer3_spks) != 0:
        frequent_counter = Counter(layer3_spks)
        prediction = frequent_counter.most_common(1)[0][0]
    else:
        prediction = -1

    if prediction == label:
        correct_samples += 1

    test_samples += 1
    inference_p_bar.set_description(
        f"label: {label} prediction: {prediction}，current ACC：{correct_samples / test_samples}，layer 3 output spikes num: {len(layer3_spks)}")

print(f"On chip inference accuracy: {correct_samples / test_samples}")